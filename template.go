package main

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/golang/protobuf/protoc-gen-go/descriptor"
)

type importValues struct {
	RelativeImportBase string
	Path               string
	TypeMap            map[string]struct{}
	Types              []string
}

const importTemplate = `
import { {{range $i, $t := .Types -}}
  {{- if $i}}, {{end -}}
  {{- $t -}}
{{- end}} } from "{{.RelativeImportBase}}{{.Path}}";
`

func (iv *importValues) Compile() (string, error) {
	return compileAndExecute(importTemplate, iv)
}

type enumKeyVal struct {
	Name  string
	Value int32
}

type enumValues struct {
	Name   string
	Values []*enumKeyVal
}

const enumTemplate = `
{{$enumName := .Name}}
export enum {{$enumName}} {
  {{- range $i, $v := .Values}}
  {{- if $i}},{{end}}
  {{$v.Name}} = "{{$v.Name}}"
  {{- end}}
}
`

func (ev *enumValues) Compile() (string, error) {
	return compileAndExecute(enumTemplate, ev)
}

type messageValues struct {
	Name          string
	Interface     string
	JSONInterface string

	Fields      []*fieldValues
	NestedTypes []*messageValues
	NestedEnums []*enumValues
}

var messageTemplate = `
export interface {{.Interface}} {
  {{- if .Fields }}
  {{- range .Fields}}
  {{.Field }}?: {{. | fieldType}};
  {{- end}}
  {{- end}}

  toJSON?(): object;
}

{{- if .NestedEnums}}
{{range .NestedEnums}}
{{. | compile}}
{{end}}
{{else}}

{{ end -}}

export interface {{.JSONInterface}} {
  {{- range $i, $v := .Fields}}
  {{$v.Name}}?: {{ $v | fieldType }};
  {{- end}}
  toJSON?(): object;
}

export class {{.Name}} implements {{.Interface}} {
  private _json: {{.JSONInterface}};

  constructor(m?: {{.Interface}}) {
    this._json = {};
    if (m) {
      {{- range .Fields}}
      this._json["{{.Name}}"] = m.{{.Field}};
      {{- end}}
    }
  }
  {{- range .Fields}}

  // {{.Field}} ({{.Name}})
  public get {{.Field}}(): {{. | fieldType}} {
    {{if .IsRepeated -}}
      return this._json.{{.Name}} || []
    {{- else -}}
      return this._json.{{.Name}}!
    {{- end}};
  }
  public set {{.Field}}(value: {{. | fieldType}}) {
    this._json.{{.Name}} = value;
  }
  {{- end}}

  static fromJSON(m: {{.JSONInterface}} = {}): {{.Name}} {
    return new {{.Name}}({
    {{range $i, $v := .Fields -}}
      {{- if $i}},
      {{else}}  {{end}}{{$v.Field}}: {{ $v | objectToField -}}
    {{- end}}
    });
  }

  public toJSON(): object {
    return this._json;
  }
}
`

func (mv *messageValues) Compile() (string, error) {
	return compileAndExecute(messageTemplate, mv)
}

type fieldValues struct {
	Name       string
	Field      string
	Type       string
	IsEnum     bool
	IsRepeated bool
}

type serviceValues struct {
	Package   string
	Name      string
	Interface string
	Methods   []*serviceMethodValues
}

var serviceTemplate = `
export interface {{.Interface}} {
  {{- range .Methods}}
  {{.Name | methodName}}: (
    data: {{.InputType}},
    headers?: object
  ) => Promise<{{.OutputType}}>;
  {{- end}}
}

export class {{.Name}} implements {{.Interface}} {
  private hostname: string;
  private fetch: Fetch;
  private path = "/twirp/{{.Package}}.{{.Name}}/";

  constructor(hostname: string, fetch: Fetch) {
    this.hostname = hostname;
    this.fetch = fetch;
  }

  private url(name: string): string {
    return this.hostname + this.path + name;
  }

  {{- range .Methods}}

  public {{.Name | methodName}}(
    params: {{.InputType}},
    headers: object = {}
  ): Promise<{{.OutputType}}> {
    return this.fetch(
      this.url("{{.Name}}"),
      createTwirpRequest(params, headers)
    ).then(res => {
      if (!res.ok) {
        return throwTwirpError(res);
      }
      return res.json().then(m => {
        return {{.OutputType}}.fromJSON(m);
      });
    });
  }
  {{- end}}
}
`

func (sv *serviceValues) Compile() (string, error) {
	return compileAndExecute(serviceTemplate, sv)
}

type serviceMethodValues struct {
	Name string

	Path       string
	InputType  string
	OutputType string
}

type protoFile struct {
	Output             string
	RelativeImportBase string
	Messages           []*messageValues
	Services           []*serviceValues
	Enums              []*enumValues
	Imports            map[string]*importValues
}

func (pf *protoFile) AddImport(imprt *descriptor.FileDescriptorProto, name string) {
	if importName(imprt) == "timestamp" {
		return
	}

	iv, ok := pf.Imports[imprt.GetPackage()]
	if !ok {
		iv = &importValues{
			RelativeImportBase: pf.RelativeImportBase,
			Path:               tsImportPath(imprt),
			TypeMap:            make(map[string]struct{}),
		}
		pf.Imports[imprt.GetPackage()] = iv
	}
	if _, ok := iv.TypeMap[name]; !ok {
		iv.TypeMap[name] = struct{}{}
		iv.Types = append(iv.Types, name)
	}
}

var protoTemplate = `
/* eslint-disable */

// This file has been generated by https://github.com/horizon-games/protoc-gen-twirp_ts.
// Do not edit.

{{if .Imports -}}
{{- range .Imports -}}
{{- . | compile}}
{{end -}}
{{- end -}}

{{- if .Services -}}
import { createTwirpRequest, Fetch, throwTwirpError } from "{{.RelativeImportBase}}twirp";
{{end -}}

{{- if .Enums}}
{{range .Enums -}}
{{. | compile}}
{{end -}}
{{- end}}

{{- if .Messages}}
{{range .Messages -}}
{{. | compile}}

{{end -}}
{{end}}

{{- if .Services -}}
// Services
{{range .Services}}
{{- . | compile}}
{{- end}}
{{- end}}
`

func (pf *protoFile) Compile() (string, error) {
	return compileAndExecute(protoTemplate, pf)
}

func compileAndExecute(tpl string, data interface{}) (string, error) {
	funcMap := template.FuncMap{
		"compile":       compile,
		"fieldType":     fieldType,
		"methodName":    methodName,
		"objectToField": objectToField,
	}

	t, err := template.New("").Funcs(funcMap).Parse(tpl)
	if err != nil {
		return "", err
	}

	buf := bytes.NewBuffer(nil)
	if err := t.Execute(buf, data); err != nil {
		return "", err
	}

	return strings.TrimSpace(buf.String()) + "\n", nil
}

func objectToField(fv fieldValues) string {
	t := fv.Type

	if t == "Date" {
		t = "string"
	}

	if fv.IsRepeated {
		switch t {
		case "string", "number", "boolean":
			return fmt.Sprintf(strings.TrimSpace(`
(m["%s"]! || []).map(v => {
        return %s(v);
      })
`),
				fv.Name, upperCaseFirst(t),
			)
		}

		if fv.IsEnum {
			return fmt.Sprintf(strings.TrimSpace(`
(m["%s"]! || []).map(v => {
        return (<any>%s)[v];
      })
`),
				fv.Name, fv.Type,
			)
		}

		return fmt.Sprintf(strings.TrimSpace(`
(m["%s"]! || []).map(v => {
        return %s.fromJSON(v);
      })
`),
			fv.Name, t)
	}

	switch t {
	case "string", "number", "boolean":
		return fmt.Sprintf(`m["%s"]!`, fv.Name)
	}

	if fv.IsEnum {
		return fmt.Sprintf(`(<any>%s)[m["%s"]!]!`, fv.Type, fv.Name)
	}

	return fmt.Sprintf(`%s.fromJSON(m["%s"]!)`, t, fv.Name)
}

func typeToInterface(typeName string) string {
	return "I" + typeName
}

func typeToJSONInterface(typeName string) string {
	return "I" + typeName + "JSON"
}

func methodName(method string) string {
	return strings.ToLower(method[0:1]) + method[1:]
}

type exportValues struct {
	Exports []string
}

const exportTemplate = `
/* eslint-disable */

// This file has been generated by https://github.com/horizon-games/protoc-gen-twirp_ts.
// Do not edit.

{{range $i, $e := .Exports -}}
export * from "./{{$e}}";
{{end -}}
`

func (ev *exportValues) Compile() (string, error) {
	return compileAndExecute(exportTemplate, ev)
}
